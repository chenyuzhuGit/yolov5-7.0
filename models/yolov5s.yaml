# Ultralytics YOLOv5 🚀, AGPL-3.0 license

# 1、参数配置
# Parameters
# 所判断目标类别的种类，此处80类
nc: 80 # number of classes
# 模型层数因子 控制模型的深度（BottleneckCSP个数）
depth_multiple: 0.33 # model depth multiple
# 模型通道数因子 控制Conv通道channel个数（卷积核数量）
width_multiple: 0.50 # layer channel multiple
# 2、先验框配置
anchors:
  # 9个anchor，其中P表示特征图的层级，P3/8该层特征图缩放为1/8,是第3层特征
  # P3/8 FPN接主干网络下采样8倍后的anchor大小,检测小目标,10,13是一组尺寸，总共三组检测小目标
  - [10, 13, 16, 30, 33, 23] # P3/8
  # P4/16 FPN接主干网络下采样4倍后的anchor大小,检测中目标，共三组
  - [30, 61, 62, 45, 59, 119] # P4/16
  # P5/32 FPN接主干网络下采样2倍后的anchor大小,检测大目标，共三组
  - [116, 90, 156, 198, 373, 326] # P5/32

# 3、backbone部分
# YOLOv5 v6.0 backbone
backbone:
  # [from, number, module, args]
    #  from ：   表示当前模块的输入来自那一层的输出，-1表示将上一层的输出当做自己的输入（第0层的-1表示输入的图像）。
    #  number：  表示当前模块的重复次数，实际的重复次数还要由上面的参数depth_multiple共同决定，决定网络模型的深度。
    #  module：  表示该层模块的名称，这些模块写在common.py中，进行模块化的搭建网络。
    #  args：  表示类的初始化参数，用于解析作为 moudle 的传入参数，会在网络搭建过程中根据不同层进行改变，我们后面具体分析。
  [
    # -1:  输入是图片；1：网络模块数量为1；该层的网络层名字是Conv；• [64, 6, 2, 2]：
      #Conv层的四个参数
      #• 64：channel=64
      #• 6：kernel_size=6
      #• 2：padding=2
      #• 2：stride=2
      #• 输出图片：320*320*64
    [-1, 1, Conv, [64, 6, 2, 2]], # 0-P1/2
      #• -1:  输入是上一层的输出
      #• 1：网络模块数量为1
      #• Conv: 该层的网络层名字是Conv
      #• [128, 3, 2]：Conv层的三个参数
      #• 128：channel=128
      #• 3：kernel_size=3
      #• 2：stride=2
      #• 输出图片：160*160*128
    [-1, 1, Conv, [128, 3, 2]], # 1-P2/4
      #• -1:  输入是上一层的输出
      #• 3：网络模块数量为3
      #• C3: 该层的网络层名字是C3
      #• [128]：C3层的参数
      #• 128：channel=128
      #• 输出图片：160*160*128
    [-1, 3, C3, [128]],
      #• -1:  输入是上一层的输出
      #• 1：网络模块数量为1
      #• Conv: 该层的网络层名字是Conv
      #• [256, 3, 2]：Conv层的三个参数
      #• 256：channel=256
      #• 3：kernel_size=3
      #• 2：stride=2
      #• 图片变化：80*80*256
    [-1, 1, Conv, [256, 3, 2]], # 3-P3/8
      #•-1:  输入是上一层的输出
      #• 6：网络模块数量为6
      #• C3: 该层的网络层名字是C3
      #• [256]：C3层的参数
      #• 256：channel=256
      #• 图片变化：80*80*256
    [-1, 6, C3, [256]],
      #• -1:  输入是上一层的输出
      #• 1：网络模块数量为1
      #• Conv: 该层的网络层名字是Conv
      #• [512, 3, 2]：Conv层的三个参数
      #• 512：channel=512
      #• 3：kernel_size=3
      #• 2：stride=2
      #• 输出图片：40*40*512
    [-1, 1, Conv, [512, 3, 2]], # 5-P4/16
      #• -1:  输入是上一层的输出
      #• 9：网络模块数量为9
      #• C3: 该层的网络层名字是C3
      #• [512]：C3层的参数
      #• 512：channel=512
      #• 输出图片：40*40*512
    [-1, 9, C3, [512]],
      #• -1:  输入是上一层的输出
      #• 1：网络模块数量为1
      #• Conv: 该层的网络层名字是Conv
      #• [1024, 3, 2]：Conv层的三个参数
      #• 1024：channel=1024
      #• 3：kernel_size=3
      #• 2：stride=2
    [-1, 1, Conv, [1024, 3, 2]], # 7-P5/32
      #• -1:  输入是上一层的输出
      #• 3：网络模块数量为3
      #• C3: 该层的网络层名字是C3
      #• [1024]：C3层的参数
      #• 1024：channel=1024
      #• 输出图片：20*20*1024
    [-1, 3, C3, [1024]],
      #• 主要是对不同尺度特征图的融合
      #• -1:  输入是上一层的输出
      #• 1：网络模块数量为1
      #• SPPF: 该层的网络层名字是SPPF
      #• [1024, 5]：SPPF层的两个参数
      #• 1024：channel=1024
      #• 5：kernel_size=5
      #• 输出图片：20*20*1024
    [-1, 1, SPPF, [1024, 5]], # 9

    #  到第9层为止，backbone部分就结束了，这个部分会形成三个接口：
    #• 第4层的输出：80*80*256
    #• 第6层的输出：40*40*512
    #• 第9层的输出：20*20*1024
  ]

# 4、head部分
# YOLOv5 v6.0 head
head: [
    # 前两个阶段是向上concat
    [-1, 1, Conv, [512, 1, 1]],
     # nn.upsample不改变channel但是会把图片宽和高都变为2倍
    [-1, 1, nn.Upsample, [None, 2, "nearest"]],
    # 与上面backbone中的 P4阶段的最后一个输出做一个concat
    # 进行concat的两层必须大小相同、通道数相同 concat之后通道翻倍
    [[-1, 6], 1, Concat, [1]], # cat backbone P4
    [-1, 3, C3, [512, False]], # 13


    [-1, 1, Conv, [256, 1, 1]],
    [-1, 1, nn.Upsample, [None, 2, "nearest"]],
    [[-1, 4], 1, Concat, [1]], # cat backbone P3
    [-1, 3, C3, [256, False]], # 17 (P3/8-small)

    # 后两个阶段是向下concat
    [-1, 1, Conv, [256, 3, 2]],
    [[-1, 14], 1, Concat, [1]], # cat head P4
    [-1, 3, C3, [512, False]], # 20 (P4/16-medium)

    [-1, 1, Conv, [512, 3, 2]],
    [[-1, 10], 1, Concat, [1]], # cat head P5
    [-1, 3, C3, [1024, False]], # 23 (P5/32-large)

    # 有三个检测层，分别是在17层下面、20层下面、23层下面
    [[17, 20, 23], 1, Detect, [nc, anchors]], # Detect(P3, P4, P5)
  ]
